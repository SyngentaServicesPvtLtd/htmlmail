<?php
/* $Id$ */

/**
 * This is the HTML Mail module to allow system email to send in HTML format.
 */
 
function htmlmail_help($section='') {
  $output = '';
  switch ($section) {
    case "admin/help#htmlmail":
      $output = '<p>'.  t("This is the HTML Mail module to allow system email to send in HTML format."). '</p>';
      break;
  }
  return $output;
}

function htmlmail_mail_alter($mailkey, &$recipient, &$subject, &$body, &$sender, &$headers) {
  $headers['Content-Type'] = 'text/html; charset="us-ascii';
	
	// The paragraph an break stuff
  if (variable_get('htmlmail_autop', '') == 1) {
	  $body = _mail_autop($body);
	}
  // Insert the preformatted HTML so the end user only needs to enter what goes between the <body> tags.
	// this of course can be overridden in the admin settings for this module.
	if (variable_get('htmlmail_preformat', '') == 1) {
    $header = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">' . "\n" .
              '<html xmlns="http://www.w3.org/1999/xhtml">' . "\n" .
              '<head>' .
              '<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />' . "\n" .
              '</head>' . "\n" .
              '<body>' . "\n";

	  $body = $header . $body;
		$body .= '</body>' . "\n" .
             '</html>' . "\n";
	}
	
  return;
}

function htmlmail_menu() {
  $items = array();
  $items[] = array(
    'path' => 'admin/settings/htmlmail',
    'title' => t('HTML Mail'),
    'callback' => 'drupal_get_form',
    'callback arguments' => 'htmlmail_admin',
    'description' => t('Configure HTML Mail administration options.'),
    'access' => user_access('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
   );
  return $items;
}

function htmlmail_admin() {

  $form['htmlmail_settings']['htmlmail_autop'] = array(
	  '#type' => 'checkbox',
    '#title' => t('Line break converter'),
    '#default_value' => variable_get('htmlmail_autop', '1'),
    '#description' => t('Converts line breaks into HTML (i.e. &lt;br&gt; and &lt;p&gt; tags, ala filter.module).')
  );
	
  $form['htmlmail_settings']['htmlmail_preformat'] = array(
	  '#type' => 'checkbox',
    '#title' => t('Preformat HTML code'),
    '#default_value' => variable_get('htmlmail_preformat', '1'),
    '#description' => t('Automagically inserts the &lt;HTML&gt; &lt;HEAD&gt; &lt;BODY&gt; tags, untick if you want control over this.')
  );
  return system_settings_form($form);
	
}

/**
 * Convert line breaks into <p> and <br> in an intelligent fashion.
 * Based on: http://photomatt.net/scripts/autop
 */
function _mail_autop($text) {
  // All block level tags
  $block = '(?:table|thead|tfoot|caption|colgroup|tbody|tr|td|th|div|dl|dd|dt|ul|ol|li|pre|select|form|blockquote|address|p|h[1-6])';

  // Split at <pre>, <script>, <style> and </pre>, </script>, </style> tags.
  // We don't apply any processing to the contents of these tags to avoid messing
  // up code. We look for matched pairs and allow basic nesting. For example:
  // "processed <pre> ignored <script> ignored </script> ignored </pre> processed"
  $chunks = preg_split('@(</?(?:pre|script|style)[^>]*>)@i', $text, -1, PREG_SPLIT_DELIM_CAPTURE);
  // Note: PHP ensures the array consists of alternating delimiters and literals
  // and begins and ends with a literal (inserting NULL as required).
  $ignore = FALSE;
  $ignoretag = '';
  $output = '';
  foreach ($chunks as $i => $chunk) {
    if ($i % 2) {
      // Opening or closing tag?
      $open = ($chunk[1] != '/');
      list($tag) = split('[ >]', substr($chunk, 2 - $open), 2);
      if (!$ignore) {
        if ($open) {
          $ignore = TRUE;
          $ignoretag = $tag;
        }
      }
      // Only allow a matching tag to close it.
      else if (!$open && $ignoretag == $tag) {
        $ignore = FALSE;
        $ignoretag = '';
      }
    }
    else if (!$ignore) {
      $chunk = preg_replace('|\n*$|', '', $chunk) ."\n\n"; // just to make things a little easier, pad the end
      $chunk = preg_replace('|<br />\s*<br />|', "\n\n", $chunk);
      $chunk = preg_replace('!(<'. $block .'[^>]*>)!', "\n$1", $chunk); // Space things out a little
      $chunk = preg_replace('!(</'. $block .'>)!', "$1\n\n", $chunk); // Space things out a little
      $chunk = preg_replace("/\n\n+/", "\n\n", $chunk); // take care of duplicates
      $chunk = preg_replace('/\n?(.+?)(?:\n\s*\n|\z)/s', "<p>$1</p>\n", $chunk); // make paragraphs, including one at the end
      $chunk = preg_replace('|<p>\s*?</p>\n|', '', $chunk); // under certain strange conditions it could create a P of entirely whitespace
      $chunk = preg_replace("|<p>(<li.+?)</p>|", "$1", $chunk); // problem with nested lists
      $chunk = preg_replace('|<p><blockquote([^>]*)>|i', "<blockquote$1><p>", $chunk);
      $chunk = str_replace('</blockquote></p>', '</p></blockquote>', $chunk);
      $chunk = preg_replace('!<p>\s*(</?'. $block .'[^>]*>)!', "$1", $chunk);
      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*</p>!', "$1", $chunk);
      $chunk = preg_replace('|(?<!<br />)\s*\n|', "<br />\n", $chunk); // make line breaks
      $chunk = preg_replace('!(</?'. $block .'[^>]*>)\s*<br />!', "$1", $chunk);
      $chunk = preg_replace('!<br />(\s*</?(?:p|li|div|th|pre|td|ul|ol)>)!', '$1', $chunk);
      $chunk = preg_replace('/&([^#])(?![A-Za-z0-9]{1,8};)/', '&amp;$1', $chunk);
    }
    $output .= $chunk;
  }
  return $output;
}

